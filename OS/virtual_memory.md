> **动态装载**

因为可执行程序本身大小可能大于物理内存大小，所以不能像静态加载方式那样一次性将可执行程序（指令以及数据的集合体）一次性加载到物理内存中去。

根据程序的局部性原理，只使一部分最常用的可执行程序驻留在内存中，这样就是动态装载。

动态装载的实现方式是**页映射（Paging）**。也就是将物理内存和虚拟内存分别划分为一个个固定大小的存储单元（例如：4 MB），这些单元分别称为物理页（PP）以及虚拟页（VP）。

当物理内存已经被 VP 填满的情况下，需要换入新的 VP 到物理内存中，就需要选择有一个牺牲页换出。怎样选择有不少算法，两种最常见的算法分别是：**FIFO（先进先出算法）** 和 **LRU（最少使用算法）** （四换八，此处应有图）。

由负责管理动态装载过程的装载器（或者说管理员）来调度这些页的换入换出（实质上这个管理角色就是操作系统）。



> **进程的虚拟地址空间**

在 32 位机器上，对一个进程来说，理论可寻址虚拟地址为 4 GB。其中 1 GB 是操作系统内核使用（图中灰色部分）。

![](https://raw.githubusercontent.com/huibazdy/TyporaPicture/main/mem.png)



> **创建进程**

从操作系统角度看，创建进程的过程做以下几件事：

1. 创建进程的虚拟地址空间；
2. 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系；
3. 将 CPU 的指令寄存器置为可执行文件的入口地址，启动运行。



* **创建虚拟地址空间**

  实际上是创建一个用于映射虚拟页到物理页的数据结构（页表/页目录）

  

* **虚拟空间与可执行文件映射**

  操作系统当碰到缺页错误（在物理内存中找不到可执行文件中需要的页）时它需要知道进程中所需要的页在可执行文件中的哪个位置，而这个位置就是虚拟空间与可执行文件之间的映射关系。在 Linux 中使用名为虚拟内存区域（***Virtual Memory Areas，VMA***）的数据结构来描述。



* **CPU 启动进程**

  将 CPU 的指令寄存器设置为可执行文件的入口地址就可以开始执行进程。
