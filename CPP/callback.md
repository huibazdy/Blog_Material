# 回调函数



## 函数指针

### 定义

函数指针是一个存储函数地址的变量，其声明与函数声明类似，需要三个要素：

* 返回类型
* 函数指针名
* 参数列表

例如：

```c++
int (*callback_func1)(int,int);
```

注意，上述定义是不完整，编译器要求定义函数指针的同时要对其进行初始化操作，即在定义函数指针之前需要存在一个用于初始化函数指针的函数原型。完整的函数指针声明如下：

```c++
int foo(int x,int y);
int (*callback_func1)(int,int) = &foo;    // 初始化函数指针，绑定函数地址
```



### 调用



### 传参





## 回调函数

理解回调这个概念之前，我个人认为需要对同步与异步有比较清晰的认识。如果没有，可以看看另一篇文章[快速理解同步与异步](https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485709&idx=1&sn=86738d509091e7ff0e0c16d4b9aa354f&source=41#wechat_redirect)。

在这里简单回顾下：

* **同步**

    A 任务执行到中途启动新任务 B ，等待 B完成 A 才能进行下一步动作。此时称 A 与 B 同步。 
    例如打电话，需要等待接通的过程，其中你打电话这个任务就是 A ，接通电话就是任务 B 。

* **异步**

    A 任务执行到中途启动新任务 B ，等待 B 完成任务的过程中，A 继续向前执行。其中 A 与 B 异步。
    例如发邮件，你在做任务 A 的过程中发邮件，发邮件就是 B ，你可以继续干自己的事情。

> 此处需要加入两幅程序控制权转移的图片，可以参考 CSAPP 中的图。



### 同步调用

同步调用是一种最常见的场景：

```c++
int func_A()
{
    ...   
    func_B();
    ...
}
```

A 函数中调用 B 函数，需要等 B 执行完 A 才能继续向下执行后续代码。也就是  A 需要等 B 执行完，在此期间 A 什么也做不了。此时 A 与 B 是同步关系。这种调用关系称为**同步调用**。

一个常见的实际情况是进行操作系统的系统调用，以 `read()` 系统调用为例：

```c++
int func_A()
{
    ...
    read(fd, buf);  // 进行系统调用，读取文件
    ...
}
```

在执行系统调用 read 时， A 函数停止运行，等待读取文件完成。

### 异步调用

从实际的调度出发，设想如果新发起的任务（任务 B）耗时很长，如果都采用同步方式，岂不是效率非常低下，因此异步调用应运而生。

有一个问题是，既然创建了新任务（调用 B），如果不管它继续执行，创建新任务的意义何在？所以我们需要弄清楚两个问题：

1. 调用方到底需不需要知道执行结果？
2. 如果需要，如何得知 B 执行完毕？
3. 如果需要，如何获取 B 执行结果？

这里任务执行完毕的通知方式大致分为两种：

1. 信号（不同操作系统实现方式不同）
2. 回调（callback）



## 函数对象

除了利用函数指针来实现函数的回调，还可以利用函数对象来实现。