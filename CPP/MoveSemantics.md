# 移动语义与右值

> 为什么要有移动语义

拷贝开销很大：

1. 申请新内存
2. 复制到新内存

如果被拷贝的对象中含有其他对象或者指针等数据成员，那么这种拷贝的弊端更明显。



C++程序中存在大量临时对象：

1. 函数返回值

2. 自定义类型计算后产生的临时对象

   ```c++
   // 编译器先计算前两者的结果一个临时对象temp存储结果，然后再计算temp与c3的结果并复制给res
   Complex res = c1 + c2 + c3;

3. 按值传递的形参

令一个方面：虽然通过传引用形参的方式可以避免拷贝对象，去无法避免另外两种临时对象的拷贝。移动语义本质就是获取临时对象的所有权，而不是通过拷贝来获得。



【例 1】

```c++
class A
{
public:
    A(const std::string &str):s(str){}
private:
    std::string s;
};
```

新建对象：

```c++
#include <A>

int main()
{
    ...
	A a1("happy");
    A a2 = a1;
	...
}
```

【例 2】

```c++
int main()
{
	...
	std::vector<A> v;
    A a1("happy");
    v.push_back(a1);
    v.push_back(a1);
}
```



> 移动语义概念

* ***为什么要有移动语义？***

  传统数据拷贝操作过程耗时，且需要占用额外内存。

* ***什么是移动语义？***

  简单来说，移动语义就是将一个对象（M）在其生命周期内的所有权从一个对象（A）转移到另一个对象（B）中，从而避免数据拷贝。可以理解为一种轻量级“复制”操作。



> 移动语义的实现

C++11 中是通过右值引用（`&&`）来实现的。



> 右值

* 左值或右值是表达式的属性
* C++ 的表达式要么是左值，要么是右值
* 最初概念来源于 C语言，左值能位于赋值语句左侧，右值不能
* C++ 中，左值表达式求值结果是一个对象或者函数（常量对象不能作为左值在赋值语句左侧）
* 当一个对象被用作右值时，用的是对象的值（内容）
* 当一个对象被用作左值时，用的是对象的身份（内存中的位置）
* 可以通过取地址运算符获取地址的就是左值？？
* 右值是字面常量或表达式求值过程中创建的临时对象



> 右值引用

为了支持移动操作，C++11 引入了新的引用类型：右值引用（rvalue reference）。右值引用就是必须绑定到右值的引用。通过`&&`来获得右值引用。

右值引用重要性质：只能绑定到一个将要销毁的对象。

从而将一个右值引用的子源“移动”到另一个对象中。

```c++
int i = 10;
int &r = i;       // 正确，左值引用绑定到左值
int &&r1 = i;     // 错误，不能将右值引用绑定到左值上
int &r2 = i * 4;  // 错误，不能将左值引用绑定到右值上
const int &r3 = i * 4;  // 正确，可以将const引用绑定到右值上
int &&r4 = i * 4; // 正确，右值引用绑定到右值上
int &&r5 = 40;    // 正确，字面常量是右值
int &&r6 = r5;    // 错误，表达式 r5 是左值
```



> 左值和右值的区别：左值持久，右值短暂（《cpp primer》13.6.1）

1. 左值有持久状态
2. 右值是字面常量或表达式求值过程中创建的临时对象

由于右值引用只能绑定到临时对象。可以得出：

1. 所引用对象即将被销毁
2. 该对象没有其他用户

这个特性说明：右值引用的代码可以自由接管所引用的对象的资源。我们可以从绑定到右值引用的对象“窃取”状态。



> 左值

变量是左值，不能将一个右值引用绑定到一个变量上，即使这个变量是右值引用类型也不行，因为它依旧是左值

```c++
int &&r1 = 20;  
int &&r2 = r1;  // 错误，右值引用不能绑定到左值
```

【注意】**右值引用本身是左值**



> **`std::move()`**

虽然不能将右值引用绑定到左值上，但可以显示将一个左值强制转换为右值类型。

```c++
#include <utility>

int &&r1 = 20;            // 右值引用绑定到右值
int &&r2 = std::move(r1)  // 正确
```



> 移动语义的应用

函数`f1()`

```c++
void f1(const std::string &r) {...}  // 形参是左值，调用时需要拷贝
```

优化后的`f1()`

```c++
void f1(std::string &&r) {...}  // 形参是右值
```



在使用这个函数时，可以通过`std::move()`来将左值转为右值引用：

```c++
#include <string>

int main()
{
    std::string s = "hello";
    f1(std::move(s));  // 将传递左值实参转换为传递右值实参，避免拷贝
    return 0;
}
```



> 移动构造函数与移动赋值运算符

类似于拷贝构造函数，移动构造函数的第一个参数也是该类对象的一个引用，不同的是这个引用是右值引用。

* “窃取”资源而不是拷贝
* 销毁资源是无害的



> 一些原则

* 类中存在指针数据成员，必须自定义拷贝构造函数与拷贝赋值运算符，实现深拷贝
* 类中存在指针数据成员，必须自定义移动构造函数与移动赋值运算符



## 参考资料

1. https://bbs.huaweicloud.com/blogs/375866
2. https://cloud.tencent.com/developer/article/2214702
3. https://xiaotaoguo.com/p/cpp-move-semantics/
4. https://www.jb51.net/article/273425.htm