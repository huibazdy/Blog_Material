# 移动语义与右值

> 移动语义概念

* ***为什么要有移动语义？***

  传统数据拷贝操作过程耗时，且需要占用额外内存。

* ***什么是移动语义？***

  简单来说，移动语义就是将一个对象（M）在其生命周期内的所有权从一个对象（A）转移到另一个对象（B）中，从而避免数据拷贝。可以理解为一种轻量级“复制”操作。



> 移动语义的实现

C++11 中是通过右值引用（`&&`）来实现的。



> 右值

* 左值或右值是表达式的属性
* C++ 的表达式要么是左值，要么是右值
* 最初概念来源于 C语言，左值能位于赋值语句左侧，右值不能
* C++ 中，左值表达式求值结果是一个对象或者函数（常量对象不能作为左值在赋值语句左侧）
* 当一个对象被用作右值时，用的是对象的值（内容）
* 当一个对象被用作左值时，用的是对象的身份（内存中的位置）
* 可以取地址的就是左值？？
* 右值是字面常量或表达式求值过程中创建的临时对象



> 右值引用

为了支持移动操作，C++11 引入了新的引用类型：右值引用（rvalue reference）。右值引用就是必须绑定到右值的引用。通过`&&`来获得右值引用。

右值引用重要性质：只能绑定到一个将要销毁的对象。

从而将一个右值引用的子源“移动”到另一个对象中。

```c++
int i = 10;
int &r = i;       // 正确，左值引用绑定到左值
int &&r1 = i;     // 错误，不能将右值引用绑定到左值上
int &r2 = i * 4;  // 错误，不能将左值引用绑定到右值上
const int &r3 = i * 4;  // 正确，可以将const引用绑定到右值上
int &&r4 = i * 4; // 正确，右值引用绑定到右值上
int &&r5 = 40;    // 正确，字面常量是右值
int &&r6 = r5;    // 错误，表达式 r5 是左值
```



> 左值和右值的区别：左值持久，右值短暂（《cpp primer》13.6.1）

1. 左值有持久状态
2. 右值是字面常量或表达式求值过程中创建的临时对象

由于右值引用只能绑定到临时对象。可以得出：

1. 所引用对象即将被销毁
2. 该对象没有其他用户

这个特性说明：右值引用的代码可以自由接管所引用的对象的资源。我们可以从绑定到右值引用的对象“窃取”状态。



> 左值

变量是左值，不能将一个右值引用绑定到一个变量上，即使这个变量是右值引用类型也不行，因为它依旧是左值

```c++
int &&r1 = 20;  
int &&r2 = r1;  // 错误，右值引用不能绑定到左值
```



> **`std::move()`**

虽然不能将右值引用绑定到左值上，但可以显示将一个左值转换为右值类型