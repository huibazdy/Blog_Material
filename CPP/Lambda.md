

> 匿名函数

需要一个函数，又不想费力去命名它的情况下来使用。使用场景很多，几乎是现代编程语言的标配 。



> C++ 中的可调用对象

1. 函数
2. 函数指针
3. lambda 表达式
4. 重载了调用运算符的类

对于可调用对象，例如：e，可以编写代码：`e(args); `args 是用逗号分隔的参数列表。



> Lambda 表达式提供了一个类似匿名函数的特性

* 一个 lambda 表达式就是一个可调用的代码单元
* 可以将其理解为一个未命名的内联函数
* 与函数不同，它可以定义在函数内部

形如：

`[捕获列表](参数列表) -> 返回类型 {函数体}`

* 捕获列表：一个 lambda 所在函数中定义的局部变量列表（一般为空），空的捕获列表说明该 lambda 表达式不使用它所在函数的任何局部变量

* 参数列表、返回类型、函数体：和普通函数一样

* 忽略参数列表等价于指定空的参数列表

* 忽略返回类型等价于根据函数体中代码自动推断返回类型（如果有return则根据其推断，否则为void）

    ```c++
    auto f = [] {return 100;};   // 定义可调用对象 f，不接受参数，返回 100

但与普通函数不同，它必须使用尾置返回（参考cpp primer 6.3.3 节）。



lambda 表达式调用方式与普通函数调用方式相同：
```c++
auto f = []() -> {return 30};
std::cout << f() << std::endl;  // 调用 lambda 表达式 f
```



带形参的 lambda 表达式：（此处实现比较 string 长短的功能）

```c++
auto f1 = [](const std::string &a, const std::string &b) {return a.size() < b.size();};
```



> 定义 lambda 时，编译器生成了一个对应的 lambda 类类型

* 当向一个函数传递一个 lambda 表达式时，同时定义了这个类以及一个类对象



> 值捕获

被捕获变量的值是在 lambda 被创建时拷贝，而不是调用时拷贝，前提是变量可以拷贝。

```c++
void f1()
{
    int v = 30;
    auto f = [v] {return v;};
    v = 0;
    auto j = f(); // j 为 30，因为 f 在被创建时保存了 v 的拷贝
}
```
