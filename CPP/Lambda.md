

> 匿名函数

需要一个函数，又不想费力去命名它的情况下来使用。使用场景很多，几乎是现代编程语言的标配 。



> C++ 中的可调用对象

1. 函数
2. 函数指针
3. lambda 表达式
4. 重载了调用运算符的类

对于可调用对象，例如：e，可以编写代码：`e(args); `args 是用逗号分隔的参数列表。



> Lambda 表达式提供了一个类似匿名函数的特性

* 一个 lambda 表达式就是一个可调用的代码单元
* 可以将其理解为一个未命名的内联函数
* 与函数不同，它可以定义在函数内部

形如：

`[捕获列表](参数列表) -> 返回类型 {函数体}`

* 捕获列表：一个 lambda 所在函数中定义的局部变量列表（一般为空），空的捕获列表说明该 lambda 表达式不使用它所在函数的任何局部变量

* 参数列表、返回类型、函数体：和普通函数一样

* 忽略参数列表等价于指定空的参数列表

* 忽略返回类型等价于根据函数体中代码自动推断返回类型（如果有return则根据其推断，否则为void）

    ```c++
    auto f = [] {return 100;};   // 定义可调用对象 f，不接受参数，返回 100

但与普通函数不同，它必须使用尾置返回（参考cpp primer 6.3.3 节）。



lambda 表达式调用方式与普通函数调用方式相同：
```c++
auto f = []() -> {return 30};
std::cout << f() << std::endl;  // 调用 lambda 表达式 f
```



带形参的 lambda 表达式：（此处实现比较 string 长短的功能）

```c++
auto f1 = [](const std::string &a, const std::string &b) {return a.size() < b.size();};
```



> 定义 lambda 时，编译器生成了一个对应的 lambda 类类型

* 当向一个函数传递一个 lambda 表达式时，同时定义了这个类以及一个类对象



> 值捕获

被捕获变量的值是在 lambda 被创建时拷贝，而不是调用时拷贝，前提是变量可以拷贝。

```c++
void f1()
{
    int v1 = 30;
    auto f = [v1] {return v1;};
    v1 = 0;
    auto j = f(); // j 为 30，因为 f 在被创建时保存了 v 的拷贝
}
```

因为被捕获变量的值是在 lambda 被创建时拷贝，所以随后对齐修改不会改变 lambda 内对应的值。



> 引用捕获

```c++
void f2()
{
    int v2 = 50;
    auto f = [&v2] {return v2;};
    v2 = 0;
    auto j = f(); // j 为 0，因为 f 在被创建时保存的是 v 的引用，而不是拷贝
}
```

* 以引用方式捕获变量时，必须保证 lambda 执行时变量是存在的



> 可变 lambda

如果希望在 lambda 中能改变被捕获变量的值，需要在参数列表后加上关键字：`mutable`。

```c++
void f3()
{
    int v3 = 80;
    auto f = [v3] () mutable {return ++v3;};
    v3 = 0;
    auto j = f(); // j 为 81
}
```



> 指定 lambda 返回类型

除了单一返回类型，以及编译器默认返回 void 类型外，有时候还需要对 lambda 表达式指定返回类型：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
    ...
	transform(vec1.begin(), vec1.end(), vec1.begin(),
             [](int i) {return i < 0 ? -i : i;});
	...
}
```

函数 transform 接受三个迭代器和一个可调用对象。参数 1 和 2 表示输入序列，参数 3 表示目的（输出）位置。在这个例子中，输入与输出目的位置的迭代器是相同的，含义是该算法将输入序列的每个元素替换为可调用对象操作该元素得到的结果。
算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。可调用对象这里采用的是 lambda 表达式，其含义是将序列中每个负数变为它的绝对值。
